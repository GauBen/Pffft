<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Pffft (pffft.Pffft)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">pffft</a> &#x00BB; Pffft</nav><h1>Module <code>Pffft</code></h1><p>Programmation fonctionnelle : un fantastique framework de test.</p><p>Cette bibliothèque fournit des fonctions de tests qui permettent d'écrire des tests avec des quantifieurs mathématiques.</p><p>Il existe deux résultats possibles : une exécution est valide ou ne l'est pas. Une exécution est déclarée valide si elle se termine, ou si on la déclare explicitement valide. Une exécution est déclarée invalide si elle est interrompue par l'échec d'une assertion, ou si on la déclare explicitement invalide.</p><nav class="toc"><ul><li><a href="#exécution-d'une-suite-de-tests">Exécution d'une suite de tests</a></li><li><a href="#primitives-d'interruption">Primitives d'interruption</a></li><li><a href="#filtrage-des-exécutions">Filtrage des exécutions</a></li><li><a href="#quantificateurs-sur-les-booléens">Quantificateurs sur les booléens</a></li><li><a href="#quantificateurs-sur-les-flux">Quantificateurs sur les flux</a></li><li><a href="#affichage-des-succès-et-des-échecs">Affichage des succès et des échecs</a></li><li><a href="#quantificateurs-sur-les-longueurs-de-liste">Quantificateurs sur les longueurs de liste</a></li></ul></nav></header><section><header><h2 id="exécution-d'une-suite-de-tests"><a href="#exécution-d'une-suite-de-tests" class="anchor"></a>Exécution d'une suite de tests</h2></header><dl><dt class="spec value" id="val-check"><a href="#val-check" class="anchor"></a><code><span class="keyword">val</span> check : <span>(unit <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Exécute un programme instrumenté avec les fonctions ci-dessous. Le resultat booléen représente la validité de l'exécution et permet de s'interfacer avec <code>let%test</code> de <code>ppx_inline_test</code>.</p><p>Il est conseillé de préfixer la fonction passée en argument avec <code>Pffft.</code> pour ne pas avoir à préfixer tous les appels :</p><pre><code class="ml">let%test _ =
  let is_lower c = c = Char.lowercase_ascii c in
  Pffft.check
    Pffft.(
      fun () -&gt;
        let c = forall (Flux.of_list [ 'h'; 'e'; 'y'; 'H'; 'i' ]) in
        assertion (fun () -&gt; is_lower c))</code></pre><p>Dans l'exemple au dessus, <code>forall</code> et <code>assertion</code> ne sont pas préfixé.</p><p>Dans cet exemple, la variable <code>c</code> va prendre les valeurs <code>'h'</code>, <code>'e'</code>, <code>'y'</code> et passer l'assertion. Lorsque <code>c</code> va prendre la valeur <code>'H'</code>, l'assertion va échouer et, comme l'assertion n'est pas vraie pour toutes les valeurs du flux, le test va échouer :</p><pre>File &quot;...&quot;: &lt;&lt;Pffft.check   (let open Pffft in      fun () [...]&gt;&gt; is false.
FAILED 1 / 1 test</pre><p>Au lieu de vérifier si l'assertion est vraie pour tout <code>c</code>, on peut vérifier qu'il existe un <code>c</code> vérifiant l'assertion :</p><pre><code class="ml">let%test _ =
  let is_lower c = c = Char.lowercase_ascii c in
  Pffft.check
    Pffft.(
      fun () -&gt;
        let c = forsome (Flux.of_list [ 'H'; 'E'; 'Y'; 'h'; 'I' ]) in
        assertion (fun () -&gt; is_lower c))</code></pre><p>Cette fois-ci, le test passe car il existe une valeur testée qui passe l'assertion, <code>'h'</code>.</p></dd></dl></section><section><header><h2 id="primitives-d'interruption"><a href="#primitives-d'interruption" class="anchor"></a>Primitives d'interruption</h2></header><dl><dt class="spec value" id="val-miracle"><a href="#val-miracle" class="anchor"></a><code><span class="keyword">val</span> miracle : unit <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Interrompt l'exécution et la rend valide.</p><p>Cette primitive n'a pas de raison particulière d'être utilisée directement, mais on peut s'en servir pour rendre une suite d'instructions valide.</p></dd></dl><dl><dt class="spec value" id="val-failure"><a href="#val-failure" class="anchor"></a><code><span class="keyword">val</span> failure : unit <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Interrompt l'exécution et la rend invalide. De même, <code>failure</code> n'a pas de raisson particulière d'être utilisée seule.</p></dd></dl></section><section><header><h2 id="filtrage-des-exécutions"><a href="#filtrage-des-exécutions" class="anchor"></a>Filtrage des exécutions</h2></header><dl><dt class="spec value" id="val-assumption"><a href="#val-assumption" class="anchor"></a><code><span class="keyword">val</span> assumption : <span>(unit <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Filtre et ne continue que les executions qui vérifient le prédicat passé en paramètre. Les autres exécutions sont simplement arrêtées et déclarées valides. Ceci correspond à la sémantique d'une précondition, i.e. on n'exécute un programme que si sa précondition est vraie, i.e. on ignore les autres exécutions.</p><p>Par exemple, on peut exclure les cas où <code>a</code> ≥ <code>b</code> où les variables <code>a</code> et <code>b</code> sont définies auparavant : <code>assumption (fun () -&gt; a &lt; b)</code>.</p><p>On peut alors écrire des tests sous la forme :</p><ul><li>Pour tout <code>a</code> dans un tel ensemble : <code>let a = forall (Flux.of_list e) in</code></li><li>Pour tout <code>b</code> dans un autre ensemble : <code>let b = forall (Flux.of_list f) in</code></li><li>Tels que <code>a</code> &lt; <code>b</code> : <code>assumption (fun () -&gt; a &lt; b);</code></li><li>...</li></ul></dd></dl><dl><dt class="spec value" id="val-assertion"><a href="#val-assertion" class="anchor"></a><code><span class="keyword">val</span> assertion : <span>(unit <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Filtre et ne continue que les executions qui vérifient le prédicat passé en paramètre. Les autres exécutions sont simplement arrêtées et déclarées invalides. Ceci correspond à la sémantique d'une postcondition, i.e. on ne valide l'exéecution que si la postcondition est vraie, i.e. les autres executions sont invalides et correspondent à une erreur.</p><p><code>assertion</code> correspond généralement à la propriété qu'on veut montrer, et est par conséquent souvent à la fin de la fonction testée. Des exemples sont donnés plus bas, à <a href="index.html#val-forall"><code>forall</code></a> et <a href="index.html#val-forsome"><code>forsome</code></a>.</p></dd></dl></section><section><header><h2 id="quantificateurs-sur-les-booléens"><a href="#quantificateurs-sur-les-booléens" class="anchor"></a>Quantificateurs sur les booléens</h2></header><dl><dt class="spec value" id="val-forall_bool"><a href="#val-forall_bool" class="anchor"></a><code><span class="keyword">val</span> forall_bool : unit <span>&#45;&gt;</span> bool</code></dt><dd><p>Crée deux exécutions de la suite du programme, renvoie <code>true</code> dans l'une et <code>false</code> dans l'autre. Pour que l'exécution parente soit valide, les deux exécutions filles doivent être valides.</p><p>On peut mettre en évidence le <i>fork</i> réalisé par <code>forall_bool</code> :</p><pre><code class="ml">let _ =
  Pffft.check (fun () -&gt;
      let b = Pffft.forall_bool () in
      if b then print_endline &quot;true&quot; else print_endline &quot;false&quot;)</code></pre><p>L'exécution affiche <code>true false</code>, preuve que deux exécutions sont lancées, l'une dans laquelle la variable <code>b</code> vaut <code>true</code> puis <code>false</code> dans l'autre.</p><p>L'exécution est paresseuse, par conséquent si la première exécution échoue, la seconde ne sera pas lancée et l'exécution parente sera déclarée invalide.</p></dd></dl><dl><dt class="spec value" id="val-forsome_bool"><a href="#val-forsome_bool" class="anchor"></a><code><span class="keyword">val</span> forsome_bool : unit <span>&#45;&gt;</span> bool</code></dt><dd><p><i>Forke</i> l'exécution courante en deux versions. Dans chacune de ces versions, <code>forsome_bool</code> renvoie un booléen différent. L'exécution parente est valide si et seulement si au moins une des deux exécutions filles l'est.</p><p>L'exécution est paresseuse, si la première est valide, la seconde n'est pas lancée et l'exécution parente est déclarée valide.</p></dd></dl></section><section><header><h2 id="quantificateurs-sur-les-flux"><a href="#quantificateurs-sur-les-flux" class="anchor"></a>Quantificateurs sur les flux</h2></header><dl><dt class="spec value" id="val-forall"><a href="#val-forall" class="anchor"></a><code><span class="keyword">val</span> forall : <span><span class="type-var">'a</span> <a href="../Flux/index.html#type-t">Flux.t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Exécute la suite pour chaque élément du flux passé en argument.</p><p><code>forall</code> correspond au quantificateur ∀ : on peut écrire « ∀ x ∈ E » avec le code <code>let x = forall (Flux.of_list e)</code>, dans le cas où on représente l'ensemble E avec la liste <code>e</code>.</p><p>L'exécution n'est déclarée valide que si toutes les exécutions filles le sont. Si le flux est vide, l'exécution est déclarée valide. L'exécution est paresseuse : la première exécution fille invalide entraine l'invalidation de l'exécution parente.</p><p>Par exemple, on peut créer une fonction qui vérifie la primalité des entiers :</p><pre><code class="ml">let is_prime n =
  let range a b =
    Flux.unfold (fun x -&gt; if x &lt;= b then Some (x, x + 1) else None) a
  in
  n &gt;= 2
  &amp;&amp; Pffft.check
       Pffft.(
         fun () -&gt;
           let i = forall (range 2 (n / 2)) in
           assertion (fun () -&gt; n mod i &lt;&gt; 0))</code></pre><p>Cette fonction est la traduction directe de « n premier ⇔ pour tout i dans [2; n/2], i ne divise pas n ».</p></dd></dl><dl><dt class="spec value" id="val-forsome"><a href="#val-forsome" class="anchor"></a><code><span class="keyword">val</span> forsome : <span><span class="type-var">'a</span> <a href="../Flux/index.html#type-t">Flux.t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Correspond au quantificateur ∃ : on peut écrire « ∃ x ∈ E » avec le code <code>let x = forsome (Flux.of_list e)</code>, dans le cas où on représente l'ensemble E avec la liste <code>e</code>.</p><p>L'exécution n'est déclarée valide que si au moins une exécution fille l'est. Si le flux est vide, l'exécution est déclarée invalide. L'exécution est paresseuse : la première exécution fille valide entraine la validation de l'exécution parente.</p><p>Par exemple, on peut créer une fonction qui vérifie qu'un ensemble contient un autre ensemble, dans le cas où on modélise les ensembles avec des listes sans doublon :</p><pre><code class="ml">let is_subset subset set =
  Pffft.check
    Pffft.(
      fun () -&gt;
        let x = forall (Flux.of_list subset) in
        let y = forsome (Flux.of_list set) in
        assertion (fun () -&gt; x = y))</code></pre><p>Cette fonction est la traduction directe de « subset ⊂ set ⇔ ∀ x ∈ subset, ∃ y ∈ set, x = y ».</p></dd></dl><dl><dt class="spec value" id="val-foratleast"><a href="#val-foratleast" class="anchor"></a><code><span class="keyword">val</span> foratleast : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Flux/index.html#type-t">Flux.t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>L'exécution parente est valide si est seulement si au moins <code>n</code> exécutions filles le sont. On a <code>Pffft.forsome = Pffft.foratleast 1</code>.</p><p>Par exemple, on peut s'en servir pour vérifier l'équivalence « a non premier ⇔ il existe au moins 3 diviseurs de a » :</p><pre><code class="ml">let%test _ =
  (* Produit un flux d'entier de l'intervale [a; b] contenant ses bornes. *)
  let range a b =
    Flux.unfold (fun x -&gt; if x &lt;= b then Some (x, x + 1) else None) a
  in
  (* Renvoie true si n est premier, false sinon. *)
  let is_prime n =
    let rec aux n i =
      if i * i &gt; n then true else n mod i &lt;&gt; 0 &amp;&amp; aux n (i + 1)
    in
    n &gt;= 2 &amp;&amp; aux n 2
  in
  Pffft.check
    Pffft.(
      fun () -&gt;
        (* Pour tout a dans [2; 20] : *)
        let a = forall (range 2 20) in
        (* Disjonction de cas si a est premier : *)
        if is_prime a then
          (* Il existe au moins (a-2) nombres qui ne divisent pas a : *)
          let b = foratleast (a - 2) (range 1 a) in
          assertion (fun () -&gt; a mod b &lt;&gt; 0)
        else
          (* Il existe au moins 3 nombres qui ne divisent a : *)
          let b = foratleast 3 (range 1 a) in
          assertion (fun () -&gt; a mod b = 0))</code></pre><p>Si <code>foratleast n f</code> est appelé avec <code>n &lt;= 0</code>, l'exécution est déclarée valide. Si <code>n &gt; 0</code> et <code>f</code> est vide, l'exécution est déclarée invalide.</p></dd></dl></section><section><header><h2 id="affichage-des-succès-et-des-échecs"><a href="#affichage-des-succès-et-des-échecs" class="anchor"></a>Affichage des succès et des échecs</h2></header><aside><p>Il est possible d'appeler une fonction de <i>callback</i> sur une exécution, en fonction de son résultat.</p></aside><dl><dt class="spec value" id="val-on_success"><a href="#val-on_success" class="anchor"></a><code><span class="keyword">val</span> on_success : <span>(unit <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Exécute la fonction passée en paramètre si et seulement si l'exécution courante est valide.</p><p>On peut reprendre l'exemple de la fonction <a href="index.html#val-foratleast"><code>foratleast</code></a> pour ajouter l'affichage d'un message à chaque cas traité :</p><pre><code class="ml">let%test _ =
  (* Produit un flux d'entier de l'intervale [a; b] contenant ses bornes. *)
  let range a b =
    Flux.unfold (fun x -&gt; if x &lt;= b then Some (x, x + 1) else None) a
  in
  (* Renvoie true si n est premier, false sinon. *)
  let is_prime n =
    let rec aux n i =
      if i * i &gt; n then true else n mod i &lt;&gt; 0 &amp;&amp; aux n (i + 1)
    in
    n &gt;= 2 &amp;&amp; aux n 2
  in
  Pffft.check
    Pffft.(
      fun () -&gt;
        let a = forall (range 2 6) in
        if is_prime a then (
          (* Message si l'assertion est vraie pour a premier *)
          on_success (fun () -&gt;
              Format.printf &quot;%d est premier n'a que 2 diviseurs.@.&quot; a);
          let b = foratleast (a - 2) (range 1 a) in
          assertion (fun () -&gt; a mod b &lt;&gt; 0))
        else (
          (* Message si l'assertion est vraie pour a non premier *)
          on_success (fun () -&gt;
              Format.printf
                &quot;%d n'est pas premier et a au moins 3 diviseurs.@.&quot; a);
          let b = foratleast 3 (range 1 a) in
          assertion (fun () -&gt; a mod b = 0)))</code></pre><p>L'exécution affiche :</p><pre>2 est premier et n'a que 2 diviseurs.
3 est premier et n'a que 2 diviseurs.
4 n'est pas premier et a au moins 3 diviseurs.
5 est premier et n'a que 2 diviseurs.
6 n'est pas premier et a au moins 3 diviseurs.</pre></dd></dl><dl><dt class="spec value" id="val-on_failure"><a href="#val-on_failure" class="anchor"></a><code><span class="keyword">val</span> on_failure : <span>(unit <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Exécute la fonction passée en paramètre si et seulement si l'exécution courante est invalide.</p><p>Cela permet de savoir quels cas de tests ne sont pas valides.</p><p>Par exemple, on pourrait être tenté de vérifier le théorème « tout nombre impair supérieur ou égal à 3 est premier » :</p><pre><code class="ml">(* Produit un flux d'entiers de l'intervale [a; b] contenant ses bornes. *)
let range a b =
  Flux.unfold (fun x -&gt; if x &lt;= b then Some (x, x + 1) else None) a

(* Utilisation de Pffft sur le théorème : *)
let _ =
  if
    Pffft.check
      Pffft.(
        fun () -&gt;
          (* Pour tout entier n dans [3; 99] : *)
          let n = forall (range 3 99) in
          (* tel que n impair : *)
          assumption (fun () -&gt; n mod 2 = 1);
          on_success (fun () -&gt; Format.printf &quot;%d est premier.@.&quot; n);
          (* Pour tout entier p dans [2; n-1] : *)
          let p = forall (range 2 (n - 1)) in
          on_failure (fun () -&gt;
              Format.printf &quot;Contre-exemple : %d divise %d.@.&quot; p n);
          (* p ne divise pas n : *)
          assertion (fun () -&gt; n mod p &lt;&gt; 0))
  then print_endline &quot;Le théorème est vrai jusqu'à 99.&quot;
  else print_endline &quot;Le théorème est faux.&quot;</code></pre><p>L'exécution affiche :</p><pre>3 est premier.
5 est premier.
7 est premier.
Contre-exemple : 3 divise 9.
Le théorème est faux.</pre></dd></dl></section><section><header><h2 id="quantificateurs-sur-les-longueurs-de-liste"><a href="#quantificateurs-sur-les-longueurs-de-liste" class="anchor"></a>Quantificateurs sur les longueurs de liste</h2></header><dl><dt class="spec value" id="val-forall_length"><a href="#val-forall_length" class="anchor"></a><code><span class="keyword">val</span> forall_length : <span>int <a href="../Flux/index.html#type-t">Flux.t</a></span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>forall_length lengths values</code> produit des listes de longueur issue du flux <code>lengths</code>, avec les valeurs produites par <code>values</code>, et vérifie que la suite de l'exécution est valide pour toutes les longueurs produites.</p><p><code>values</code> peut être une fonction constante <code>fun () -&gt; 'a'</code> ou une fonction plus complexe <code>fun () -&gt; forall (Flux.of_list ['a'; 'b'])</code>.</p><p>On peut vérifier que, sur les listes de longueur impaire contenant des <code>'a'</code> ou des <code>'b'</code>, il y a toujours un nombre pair d'un des deux éléments :</p><pre><code class="ml">let rec count l x =
  match l with
  | [] -&gt; 0
  | t :: q when t = x -&gt; 1 + count q x
  | _ :: q -&gt; count q x
in
let l =
  forall_length
    (Flux.unfold (fun x -&gt; if x &lt;= 10 then Some (x, x + 2) else None) 1)
    (fun () -&gt; forall (Flux.of_list [ 'a'; 'b' ]))
in
assertion (fun () -&gt; count l 'a' mod 2 = 0 || count l 'b' mod 2 = 0)</code></pre><p>Attention, le quantificateur utilisé pour produire les valeurs de la liste doit être vérifié :</p><pre><code class="ml">let l =
  forall_length
    (Flux.of_list [ 1; 2 ])
    (fun () -&gt; forall (Flux.of_list [ 'a'; 'b' ]))
in
assertion (fun () -&gt; p l)</code></pre><p>va vérifier la propriété <code>(p ['a'] &amp;&amp; p ['b']) &amp;&amp; (p ['a'; 'a'] &amp;&amp; p ['a'; 'b'] &amp;&amp; p ['b'; 'a'] &amp;&amp; p ['b'; 'b'])</code>.</p><p>Alors que</p><pre><code class="ml">let l =
  forall_length
    (Flux.of_list [ 1; 2 ])
    (fun () -&gt; forsome (Flux.of_list [ 'a'; 'b' ]))
in
assertion (fun () -&gt; p l)</code></pre><p>va vérifier la propriété <code>(p ['a'] || p ['b']) &amp;&amp; (p ['a'; 'a'] || p ['a'; 'b'] || p ['b'; 'a'] || p ['b'; 'b'])</code>.</p><p>L'exécution est paresseuse, et est déclarée invalide à la première erreur. Si le flux des longueurs est vide, l'exécution est déclarée valide.</p></dd></dl><dl><dt class="spec value" id="val-forsome_length"><a href="#val-forsome_length" class="anchor"></a><code><span class="keyword">val</span> forsome_length : <span>int <a href="../Flux/index.html#type-t">Flux.t</a></span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>forsome_length lengths values</code> produit des listes de longueur issue du flux <code>lengths</code> avec les valeurs produites par <code>values</code>, et vérifie que la suite de l'exécution est valide pour au moins une des longueurs produites.</p><p>Attention, le quantificateur utilisé pour produire les valeurs de la liste doit être vérifié :</p><pre><code class="ml">let l =
  forsome_length
    (Flux.of_list [ 1; 2 ])
    (fun () -&gt; forall (Flux.of_list [ 'a'; 'b' ]))
in
assertion (fun () -&gt; p l)</code></pre><p>va vérifier la propriété <code>(p ['a'] &amp;&amp; p ['b']) || (p ['a'; 'a'] &amp;&amp; p ['a'; 'b'] &amp;&amp; p ['b'; 'a'] &amp;&amp; p ['b'; 'b'])</code>.</p><p>Alors que</p><pre><code class="ml">let l =
  forsome_length
    (Flux.of_list [ 1; 2 ])
    (fun () -&gt; forsome (Flux.of_list [ 'a'; 'b' ]))
in
assertion (fun () -&gt; p l)</code></pre><p>va vérifier la propriété <code>(p ['a'] || p ['b']) || (p ['a'; 'a'] || p ['a'; 'b'] || p ['b'; 'a'] || p ['b'; 'b'])</code>.</p><p>L'exécution est paresseuse, et est déclarée valide au premier succès. Si le flux des longueurs est vide, l'exécution est déclarée invalide.</p></dd></dl><dl><dt class="spec value" id="val-foratleast_length"><a href="#val-foratleast_length" class="anchor"></a><code><span class="keyword">val</span> foratleast_length : int <span>&#45;&gt;</span> <span>int <a href="../Flux/index.html#type-t">Flux.t</a></span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>foratleast_length n lengths values</code> produit des listes de longueur issue du flux <code>lengths</code> avec les valeurs produites par <code>values</code>, et vérifie que la suite de l'exécution est valide pour au moins <code>n</code> listes produites. On a <code>Pffft.forsome_length = Pffft.foratleast_length 1</code>.</p><p>Les spécifications sont similaires à <a href="index.html#val-foratleast"><code>foratleast</code></a> : si <code>n &lt;= 0</code>, l'exécution est déclarée valide. Si <code>n &gt; 0</code> et que <code>lengths</code> et vide, l'exécution est déclarée invalide.</p></dd></dl></section></div></body></html>